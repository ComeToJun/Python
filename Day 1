파이썬
첫버전 1991년 시작됨 // 이름 귀도 반 로섬 : 크리스마스때 할게 없어서 심심해서 만들어본 언어

초창기 인기 없었지만, 10여년 전부터 불붙기 시작해서 지금은 파이썬을 모르면 안되는 언어로 성장

비전공자들에게 언어를 이해시키기 위해서 선택하는 언어로 발전


파이썬 언어의 특징
1.Interpretor 
 - 기본적으로 언어에는 엄격히 말하면 두가지가 있음

compiler  
- c, c++, pascal,c#
interpretor 
- Python, BASIC, Ruby

자바는 애매하게 가운데에 걸쳐있음

<윈도우즈 기준>
컴파일러는 항상 소스코드가 있고, 이걸 컴파일러로 읽어서 실제 결합 파일(기계어)로 만들어줌 .ㅇㅇㅇexe 이런거
속도가 빠르지만, 윈도우즈에서 만든걸 리눅스에서 못씀 
리눅스에서 다시 쓰려면 리눅스로 소스코드를 가져가서 다시 리눅스용으로 만들어야함

인터프리터는 소스가 있으면, 인터프리터에서 읽어서 바로 처리를 해버림 문제를 해석해서 바로 처리해버림
별로의 ㅇㅇㅇ.exe 없이 소스만 가지고 처리 가능

좋은점은 이렇게 되니 바로 처리 가능 윈도우즈 리눅스 전부
단점은 실행속도가 느림 (소스를 읽어서 실행하는걸 계속 반복해야 하기 때문에)
대신 바로 읽어서 처리하기 때문에 대화형이라고도 함

자바는 소스파일이 ㅇㅇ.java 이기 때문에 이걸 자바로 읽으면 .class로 나옴 (빠르게 해석하기 위해)
얘를 자바 버츄얼 머신이 인터프리터 방식으로 해석을 함

대신 자바가 읽을 수 있는 class 로 있으니 인터프리터보다는 빠르지만, 
어찌되었건 두가지 방식을 전부 갖고 있다고 볼 수 있음

2.object oriented 객체지향 프로그램


3. Dynamic Typed 랭기지다

컴파일 인터프리터가 있다.
자바를 생각해보자

컴파일은
인티저 a 를 선언해야 a 에 뭔가 넣을 수 있다.
선언시에 타입을 정한다.


인터프리터는 a를 선언하면 타입이 필요없음
 - 실제 값을 넣을때 들어가는 값으로 타입이 설정됨
 - 즉, 실행이 될때 (run time 시 타입이 설정)



결과적으로 모든 프로그래밍 언어에서는 변수의 타입이 정해져야 함
타입을 알아야만 거기에 맞는 사이즈의 메모리 공간을 확보할 수 있으니까

변수의 타입이 결정되는걸 바인딩 이라고 하는데

compile 바인딩 방법
run time 바인딩 방법

랭기지 개발하는 사람들은 이렇게 분류함


이외 특징

문법이 배우기 쉽다. (처음 진입장벽이 낮다.)
하지만 언어 자체가 쉬운건 아니다.

문법이 쉬운것과 파이썬의 인기는 연관이 있다.

화학이나 물리학 천문 통계학 같은걸 전공하는 사람이 있다고 보자
대학원이나 연구원들이 연구를 하다가 이런것들을 수치상으로 표현하고 싶다고 할때는
언어를 꼭 하나 배워야 함 필요함

그러니까 이런 사람들이 배우려면 얼마나 답답하겠어 우리처럼
이럴때 등장한게 파이썬임
파이썬에는 이미 그래프나 여러가지 표현을 하기 위해서 필요한 모듈들이 엄청 많이 있음

공부 잘하는 사람들이 금방 배워서 사용하다보니
여러 학회에서 계속 나오기 시작함

시간이 지나다보니, 새롭게 들어오는 사람들의 진입장벽을 낮춰주기 위해서
자신의 분야에서 잘하던 사람들이 자신의 분야를 직접 함수로 만들기 시작 즉, 라이브러리를 만들기 시작함

자연스럽게 파이썬 생태계가 생기기 시작함 (엄청난 라이브러리가 만들어지기 시작)
결과적으로 라이브러리가 많아지니까 많은 사람들이 참고를 할 수 밖에 없음

왜냐 접근하기 쉽고, 라이브러리는 계속해서 많아지니까.

데이터 사이언스를 전공한 사람들 역시 먼저 거쳐간 사람들이 파이썬을 통해 라이브러리를 만들어 놓았기 때문에
데이터 사이언스를 공부하기 위해서도 파이썬은 필요하다.


그렇기 때문에 파이썬을 배운다. 배워야 한다.


인터프리터라 느린데 왜 좋아할까
하드웨어가 발전해서 엄청나게 빠르게 실시간으로 반응해야 하는것들이 아니라면
충분히 우리가 불편함을 느끼지 않을정도로 사용가능하기 때문이다.

----------------------------------------------------------------------------------------------

우리는 최신버전을 사용하지 않고, 모든 라이브러리를 사용하기 위해 밑 버전을 사용한다.
혹시 나중에 실습때 최신 버전을 위한것들이 아직 적용되지 않은 라이브러리가 필요해질까봐

파이썬 철학
아름다움게 추한 것보다 낫다
명시적인 것이 암시적인 것 보다 낫다
단순함이 복잡함보다 낫다
복잡함이 난해한 것보다 낫다
가독성은 중요하다.

---------------------------------------------------------------------------------------------

커멘드로 쉘을 사용하는건 귀찮다.
해당 파일에서 메모장으로 .py 파일을 만들어 할 수 있지만 print를 꼭 붙여야 함

이것도 귀찮으니 IDE 를 사용할건데

Intergrated Developmetn Environment 통합 개발 환경임 ( 이클립스와 같은 것)
** 파이참 ** 이라는 파일

특) 파이참에서는 커멘드에서 사용했던 것처럼 콘솔을 바로 사용할 수 있음


---------------------------------------------------------------------------------

파이썬
list 를 굉장히 많이 사용


************들여쓰기가 굉장히 중요









Dynamic Typed

book = "the hunt for red October"

런타임 할때 타입이 정해진다.

print(book)
the hunt for red October

결과값 
-소스를 실행시키는 순간 인터프리터가 읽어서 그 값을 넣어버림
 

python 에서는 변수값을 모두 소문자로

number _of_cylinder 
** '_' ** 을 사이사이 넣는다.

>>> a = 7
>>> a
7

>>> print(a)
7

>>> b = 5
>>> print(a+b)
12

>>> print("a" + "b")
ab

>>> a = 1.7
>>> a
1.7

>>> bool_type = True  **첫글자 대문자 기억하기
>>> bool_type
True

book = 'My name is Tom'
>>> book
'My name is Tom'


----------------------------------------------
" " , ' ' 두개 전부 문자열 사용 가능

>>> book = "she's..."
>>> book = 'He said, "Hi" '

이런 경우를 위해 사용
-----------------------------------------------

>>> book = """sssss
... adfa
... adfadf
... adfadf
... adfadf"""
>>> book
'sssss\nadfa\nadfadf\nadfadf\nadfadf'

여러줄 한번에 처리 하기

-----------------------------------------------------

True == 1
True
>>> True == 0
False

내부적으로는 이렇게 판단을 하기도 한다. (if 에 1 이 들어가 있으면 True 로 판단한다)

------------------------------------------------------------


print( 2 ** 3)
8
제곱
print(7 / 2)

3.5
>>> print(7 // 2)
3
>>> print(7 % 2)
1

나누기/ 몫// 나머지%
 
---------------------------------------------------------

>>> print(1 % 5)
1

>>>print(-1 % 5)
4

A%B 는 0~ (B-1) 사이의 값이 나오게 되어있다.


1 % 5 = 1
(1+5) % 5 = 1

A%B = (A+B)%B

-1 % 5 = 4 % 5

print(1 % -5)
-4

잘 복습해볼 것
--------------------------------------------------------------

a = 1
>>> a = a + 1
>>> print(a)
2
>>> a += 1  **
>>> print(a)
3

--------------------------------------------------


a = 10
>>> b = float(a)
>>> print(a, b)
10 10.0

c = int(b)
>>> print(a, b, c)
10 10.0 10


정수, 실수 나타내기

------------------------------------------------------

a = "76.3"
>>> b = float(a)
>>> print(a)
76.3
>>> print(a, b)
76.3 76.3

앞에는 문자열 76.3 뒤는 실수

-----------------------------------------------------
a =10.5
b= 21.8

>>> c=str(a)
>>> d=str(b)
>>>
>>> print(a+b, c+d)
32.3, 10.521.8

문자열로 바뀌었을때 나타나는 변화

--------------------------------------------

 a = 10.3
>>> type(a)
<class 'float'>
>>> b ="23"
>>> type(b)
<class 'str'>

타입 알려주기

-----------------------------------------------

파이참

print("Enter name: ")
name = input()
print("Good morning!", name)

이름 입력하면 인사해줌

한 줄 주석 #
여러줄 주석 	"""
		"""
------------------------------------------------------------

colors = ['red', 'blue', 'green']  colors 라는 리스트 객체 red blue green 라는 항목(element)을 가짐
print(colors[0])	//인덱스 해당 장소의 것을 불러옴
print(colors[2])
print(len(colors))	//개수
print(colors)	//리스트 안에 있는 항목 


-------------------------------------------------------------


mix_list = [1, 2, 'Three', 3.14, True]
print(mix_list)

타입 상관없이 다 받을 수 있음

---------------------------------------------------------------

cities = ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']
	  0       1       2       3      4       5       6       7
             -8       -7     -6      -5     -4      -3      -2  	-1
                                                                -10        -9

print(cities[0:6])
print(cities[:6])
print(cities[2:])
print(cities[-7:])
print(cities[:-2])
print(cities[:])
print(cities)
print(cities[1:7:2]) 1부터 7까지인데 그 안의 2개씩 도출
print(cities[::-1]) 끝에서부터 하나씩
print(cities[::2]) 처음부터 끝까지 2개씩

slicing 개념


----------------------------------------------------------------


color1 = ['red', 'blue', 'green']
color2 = ['orange', 'black', 'white']
add_color = color1 + color2
print(len(add_color))
print(add_color)

len 은 총 개수(길이) 구하는 것 6
리스트 합칠 수 있음

--------------------------------------------------------------

color1 = ['red', 'blue', 'green']
color2 = ['orange', 'black', 'white']
mul_color = color1 * 2
print(len(mul_color))
print(mul_color)

곱셈도 가능하다 대신 값은 다름
color 1 이 두번 연속해서 나옴

--------------------------------------------------------------

print('='*10)

결과값 ==========

직관적이라는 것을 알 수 있음

-------------------------------------------------------------------

color1 = ['red', 'blue', 'green']
color2 = ['orange', 'black', 'white']
print('blue' in color2)

항목이 해당 리스트 안에 있는가



-------------------------------------------------------------------

colors = ['red', 'blue', 'green']
colors.append('white')
print(colors)

white 추가하기 (**항목을 추가할때) append

colors = ['red', 'blue', 'green']
colors.extend(['black', 'purple'])
print(colors)

리스트를 추가할때 extend

-------------------------------------------------------------

colors = ['red', 'blue', 'green']
colors.insert(1, 'black')
colors.insert(2, 'purple')
print(colors)

insert 추가하는데 인덱스 자리에 낑겨 넣겠다. 원래 항목은 유지 되지만 밀림

----------------------------------------------------------------------------

colors = ['red', 'blue', 'green']
colors.remove('blue')
print(colors)

항목을 알고 있을때 blue 를 지움

--------------------------------------------------------------------------


colors = ['red', 'blue', 'green']
del colors[0]
print(colors)

항목을 모를때 인덱스 위치를 지정해서 지워버림

------------------------------------------------------------------

colors = ['red', 'blue', 'green']
colors[2] = 'white'
print(colors)

해당 인덱스에 있는 항목을 바꿈

------------------------------------------------------------------

colors = ['red', 'blue', 'green']      #packing
a, b, c = colors    #unpaking
print(a, b, c)

결과값 red blue green

 개수는 다 맞아야함

colors = ['red', 'blue', 'green']      #packing
a, _, c = colors    #unpaking
print(a, c)

가운데 b 를 받지 않고 싶을때

colors = ['red', 'blue', 'green']      #packing
a, b, c = colors    #unpaking
print(a, '', c)

가운데 b 를 받지 않고 싶을때 2

--------------------------------------------------------------------------

**리스트 속에 리스트도 가능 (다차원 리스트)

kor_score = [60, 65, 85, 100, 90] 	리스트 객체를 만들어서 kor 에 담음
eng_score = [75, 80, 90, 85, 100]
math_score = [100, 90, 70, 90, 85]
term_score = [kor_score, eng_score, math_score]
print(term_score)		//전체
print(term_score[0])	// term_score의 0번째 인덱스 즉, 리스트
print(term_score[0][2])	// 0번째 인덱스, 리스트의 2번째 인덱스 = 85

-------------------------------------------------------------------------------

kor_score = [60, 65, 85, 100, 90]
eng_score = [75, 80, 90, 85, 100]
math_score = [100, 90, 70, 90, 85]
math_backup_score = math_score
term_score = [kor_score, eng_score, math_score]
print(term_score)
math_score[0] = 0 		math의 0번째 인덱스를 0으로 바꾼다
print(math_score)		바뀐 math 의 0번째 인덱스가 바뀐값으로 출력
print(term_score)		전체 리스트에서 math의 인덱스가 바뀜
print(math_backup_score)	바뀐 math 리스트를 출력

---------------------------------------------------------------------------

a = ['color', 1, 0.2]
color= ['yellow', 'blue', 'red']
a[0] = color
print(a)

a 의 0번째 인덱스에 color 리스트를 넣는다.
결과값
[['yellow', 'blue', 'red'], 1, 0.2]

--------------------------------------------------------------------


a = [1, 10, 5, 6]
a.reverse()
print(a)

순서를 뒤집어서 출력


---------------------------------------------------------------------------

a = [1, 10, 5, 7, 6]
a.sort()
print(a)

정리

a = [1, 10, 5, 7, 6]
a.sort(reverse=True)
print(a)

반대로 정리 디센딩

-----------------------------------------------------------------------

a = [3, 2, 1, 4]
b = sorted(a)
print(a, b)

a 를 정리한 b 를 a와 함께 리스트로 표현
[3, 2, 1, 4] [1, 2, 3, 4]

**위의 것과 다른점은 원본보전이 가능한지 아닌지// 이건 가능.
--------------------------------------------------------------------------

a = [5, 10, 5, 7, 6]
print(a.count(5))

해당 element 가 리스트 안에 몇개 있는가.

-------------------------------------------------------------------------

appetizer = ['egg', 'salad', 'bread', 'soup', 'canape']
main_dish = ['fish', 'lamb', 'pork', 'beef', 'chicken']
dessert = ['apple', 'ice cream', 'pudding', 'cookies', 'cake']

order = [appetizer, main_dish, dessert]
jane = [order[0][:-2], main_dish[1::3], dessert[1]]   [1::3] <- 1번째 인덱스 포함 1번째 인덱스부터(해당인덱스포함안함) 3번째 인덱스 포함
del jane[2]
jane.extend([order[2][0:1]])
print(jane)

[['egg', 'salad', 'bread'], ['lamb', 'chicken'], 'ice cream'] <- dessert는 리스트가 아닌 항목 element 이기 때문에 [ 가 없다
[['egg', 'salad', 'bread'], ['lamb', 'chicken']]
[['egg', 'salad', 'bread'], ['lamb', 'chicken'], ['apple']]

// 만약 리스트로 만들면 jane = [order[0][:-2], main_dish[1::3], dessert[1:2]]

[['egg', 'salad', 'bread'], ['lamb', 'chicken'], ['ice cream'] 
[['egg', 'salad', 'bread'], ['lamb', 'chicken']]
[['egg', 'salad', 'bread'], ['lamb', 'chicken'], ['apple']]

으로 변한다.

---------------------------------------------------------------------------


print('Tell me your age?')
my_age = int(input())

input 은 기본 디폴드 값으로 스트링을 갖고 있음
그래서 int 로 캐스팅이 필요함


print('Tell me your age?')
my_age = int(input())

if my_age < 30 :
    print("Welcome to the Club")
else:
    print("Oh! no. You are not accepted.")


print('Tell me your age? ', end='')   //기본값 \n 이기 때문에 end 값을 '' 로 주면 
my_age = int(input())		다음줄로 넘어가지 않고 옆에서 숫자 입력 가능

if my_age < 30 :
    print("Welcome to the Club")
else:
    print("Oh! no. You are not accepted.")






print('Tell me your age? ', end='')
my_age = int(input())

if (my_age > 10) and (my_age < 30) :   //다른 조건넣기도 가능
    print("Welcome to the Club")
else:
    print("Oh! no. You are not accepted.")
------------------------------------------------------------------------

None 
존재하지 않는 밸류
자바에서의 null 과 같은 개념

x = None

assert x ==None,  
assert x is None,  파이썬다운 체크하는 방식

파이썬이나 사용하는 False
False, None, [], {}, "", set(), 0, 0.0
-----------------------------------------------------------------

score = int(input("Enter your score: "))

if score >= 90:
    grade = 'A'
elif score >= 80:
    grade = 'B'
elif score >= 70:
    grade = 'C'
elif score >=60:
    grade = 'D'
else:
    grade = 'F'

print(grade)

if 사용문

----------------------------------------------------------------

a = 10
b = a * 10 if a % 2 == 0 else a + 10
print(b)

a 가 10일때 b 는 100
a 가 9 일때 b 는 19

if를 기준으로 뒤에 있는 식 맞으면 if 앞에 있는걸 출력
틀리면 else 뒤에 있는걸 출력

--------------------------------------------------------------

safe_x = x or 0


safe_x = x if x else 0   같은 뜻

---------------------------------------------------------------

for n in [1, 2, 3, 4, 5]:
    print('No.', n)

for n in range(5):	0부터 5직전까지
    print('No.', n)

for n in range(1, 6, 1):   1부터 6바로 직전까지 하나씩 출력
    print("No.", n)
n 에 하나씩 대입해서 출력함

-------------------------------------------------------------------

for n in 'abcdefg':		이렇게 대입하면
    print('Char.', n)

이런 결과값

Char. a
Char. b
Char. c
Char. d
Char. e
Char. f
Char. g

---------------------------------------------------------

for n in ['banana', 'pineapple', 'mango']:
    for k in n:
        print(k)
    print()

이중 for 문
banana n 에 입장
n 바나나가 k 에 입장
한글자씩 출력
pirnt() 한줄 여유주기

--------------------------------------------------------------

i = 1
while i < 10:
    print(i)
    i += 1

1~9 까지의 수를 출력

---------------------------------------------------

for i in range(10):
    if i == 5:
        break
    print(i)
print("End of program")

break 를 만나고 나서 가장 근처에 있는 것을 찾아 반복문 탈출
4까지 출력 후 탈출

-------------------------------------------------------------


for i in range(10):
    if i == 5:
        continue
    print(i)
print("End of program")

continue 를 만나면 해당 값은 도출하지 않지만 밑으로 숫자를 계속
나오게 해준다.

1~9 중 5만 안나오고 나머지가 나온다

-----------------------------------------------------------------

for i in range(10):
    print(i)
else:
    print("End of program")

for 에서도 else 사용 가능

----------------------------------------------------------


print("몇단?")
gugu = int(input())

if gugu < 10:
    print("구구단 " + str(gugu) + "단 계산")

for gugu in range(10):
    print(gugu + "x" +  )

**************************************************

print("몇단?")
dan = input()
print("구구단", dan, "단 계산")
int_dan = int(dan)
for i in range (1, 10):
    result = int_dan * i
    print(dan, 'x', i, '=', result)

------------------------------------------------------------------

sentence = 'I love you'

for i in sentence:
    print(i[::-1], end='')

***************************************************************
reverse_sentence = ''
for char in sentence:
    reverse_sentence = char + reverse_sentence
print(reverse_sentence)

** I love you 거꾸로 뽑기 char + 니까 앞에다 먼저 문자를 빼냄

-----------------------------------------------------------------------

for c in range(-1, -len(sentence)-1, -1):
    print(sentence[c], end='')

for c in range(len(sentence)-1, -1, -1):
    print(sentence[c], end='')

rev = sentence[::-1]
print(rev)

다른 방법들
---------------------------------------------------------------

decimal = 14

result = ''
while decimal > 0:
    remainder = decimal % 2
    decimal = decimal // 2  		//몫
    result = str(remainder) + result
print(result)

10진수를 2진수로 바꾸는 방법

result = ''
a = decimal//2
b = decimal%2
c = a%2
d = c%2
e = c%2
print(str(e) + str(d) + str(c) + str(b))  내가 한거ㅡㅡ 			***다시 7/15



-------------------------------------------------------------------------


kor_score = [49, 80, 20, 100, 80]
eng_score = [43, 60, 85, 30, 90]
math_score = [49, 82, 48, 50, 100]
term_score = [kor_score, eng_score, math_score]

student_score = [0, 0, 0, 0, 0]
i = 0
for subject in term_score:
    for score in subject:
        student_score[i] += score
        i += 1
    i = 0

n_s = len(term_score)
a, b, c, d, e = student_score
student_average = [a / n_s, b / n_s, c / n_s, d / n_s, e / n_s]
print(student_average)

각 과목별로 평균 구하는 방법 (같은 인덱스 배열에 있는 항목들만 계산)








